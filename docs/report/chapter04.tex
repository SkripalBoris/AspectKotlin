%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Разработка прототипа аспектно-ориентированного расширения}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
В данном разделе рассматривается реализация прототипа в соответствии с
поставленными требованиями и разработанной архитектурой.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Средства разработки}
\label{sec:dev_tools}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Для разработки синтаксиса описания аспектов было решено использовать язык ANTLR4
про следующим причинам:
\begin{itemize}
	\item Данный язык позволяет достаточно компактно описывать грамматики и
		  генерировать парсеры по составленным грамматикам.
	\item Возможность генерации парсеров на языке Java.
	\item Существование грамматики описания аспектов на данном языке для
		  фреймворка AspectJ, синтаксис которого было решено взять за основу
		  разрабатываемой грамматики.
\end{itemize}

При разработке прототипа было решено использовать язык Kotlin.
Данный выбор был обусловлен следующими причинами:
\begin{itemize}
	\item Полная совместимость с языком Java и, как следствие, возможность
		  использовать библиотеки, разработанные для языка Java.
	\item Необходимость обеспечить достаточно высокую производительность, т.к.
		  целевые программы могут иметь достаточно большие размеры.
	\item Наличие опыта разработки на данном языке у автора работы, что
		  позволит уменьшить сроки разработки прототипа.
\end{itemize}
Разработка среды велась на языке Kotlin версии 1.0.6.
В качестве целевых программ также подразумеваются программы, написанные на языке Kotlin версии 1.0.6.

Сборка проекта производится при помощи фреймворка Apache Maven.
Данный фреймворк позволяет декларативным образом описывать проект сборки, а
также подключать сторонние библиотеки.
Одной из отличительных особенностей Maven является наличие центрального
репозитория, содержащего большое колличество библиотек, как для языка Java, так
и для языка Kotlin.
Вся информация о сборке (описание циклов сборки, подключаемые библиотеки и т.д.)
описывается в файле pom.xml (Project Object Model) в формате XML.
Еще одним критерием, по которому выбор был сделан в пользу Maven является наличие плагина, позволяющего компилировать программы на Kotlin.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Структура проекта}
\label{sec:project_structure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Условно, проект можно разбить на две логические части: часть описания
синтаксиса аспектов и часть, реализующая внедрение аспектов в целевую программу.
Ниже будет приведено описание процесса разработки двух вышеописанных частей.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Разработка грамматики аспектов}
\label{sub:aspect_grammar_part_development}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Для удобства, описание грамматики аспектов было разделено между двумя файлами:
\textit{AspectGrammar.g4} (исходный код приведен в листинге
\ref{listings:AspectGrammar}) и \textit{KotlinGrammar.g4} (исходный код
приведен в листинге \ref{listings:KotlinGrammar}).
В файле \textit{AspectGrammar.g4} описана чать грамматики, отвечающая за
грамматику непосредственно аспектов, как например, правила описания аспектов,
срезов, советов и т.д.
В файле \textit{KotlinGrammar.g4} содержится описание грамматики, относящейся к
языку Kotlin, например, стандартные типы языка, правила описания параметров
методов, модификаторы методов и т.д.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Файл AspectGrammar.g4}
\label{ssub:aspect_grammar_g4}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Точкой входа является правило \textit{aspectDeclaration} --- правило,
описывающее декларацию аспекта.
Данное правило включает в себя подправило \textit{aspectBody}, описывающее, в
свою очередь, тело аспекта, состоящее из открывающей и закрывающей фигурной
скобки между которыми находится ноль или более элементов, описанных в правиле
\textit{aspectBodyDeclaration}.
Правило \textit{aspectBodyDeclaration} может быть представлено или в виде
подправила \textit{advice}, описывающего совет, или в виде подправила
\textit{pointcut}, содержащего описание среза.

Правило описания совета содержит следующие составные части:
\begin{itemize}
	\item \textit{adviceSpec} --- спецификация совета, содержащая как позицию
		  внедрения кода совета относительно точки внедрения, так и список
		  параметров совета.
	\item Символ \quotes{:}, отделяющий спецификацию совета от описания среза.
	\item \textit{pointcutExpression} --- правило, содержащее описание среза.
	\item \textit{methodBody} --- правило, содержащее описание тела совета.
\end{itemize}

Согласно правилу \textit{adviceSpec}, спецификация совета описывается по
следующему правилу: на первом месте находится ключевое слово, описывающее
способ внедрения аспекта, после чего в скобках следует список параметров, правило описания которых содержатся в правиле \textit{formalParameters},
используемых при построении срезов, а также внутри тела аспекта.
В случае, если необходимо применить код совета после возвращения методом
значения, то к спецификации совета добавляется ключевое слово
\textit{returning}, а также тип возвращаемого значения и его идентификатор, при
помощи которого можно обращаться к значению, возвращаемому функцией,
составляющей срез.
В случае, если необходимо применить код совета после возникновения
исключительной ситуации, то к спецификации совета добавляется ключевое слово
\textit{throwning}, а также тип перехватываемого исключения и идентификатор переменной.

Правило описания среза содержит следующие составные части:
\begin{itemize}
	\item Ключевое слово \quotes{pointcut}, сигнализирующее о том, что далее
		  будет следовать описание среза.
	\item Идентификатор среза \textit{id}, уникальный в рамках совета, при
		  помощи которого можно производить обращение к данному срезу из других
		  срезов.
	\item Список параметров, используемых в срезе и описывающихся при помощи
		  правила \textit{formalParameters}.
	\item Символ \quotes{:}, отделяющий спецификацию среза от его описания.
	\item Описание среза, формализованное внутри правила
		  \textit{pointcutExpression}.
	\item Символ \quotes{;}, сигнализирующий об окончании описания среза
		  (опциональный параметр).
\end{itemize}

Правило согласно которому производится описание срезов, представлено в листинге
\ref{lst:pointcut_expression_rule}:
\begin{lstlisting}[language=Java, label={lst:pointcut_expression_rule},
  caption={Правило описания среза pointcutExpression}]
pointcutExpression
  :  (pointcutPrimitive | referencePointcut)
  |  '!' pointcutExpression
  |  '(' pointcutExpression ')'
  |  pointcutExpression '&&' pointcutExpression
  |  pointcutExpression '||' pointcutExpression
  ;
\end{lstlisting}
Как видно из листинга \ref{lst:pointcut_expression_rule}, описание среза имеет
два терминальных правила: \textit{pointcutPrimitive}, описывающий одно из
правил среза (например, \quotes{call} или \quotes{execute}) или же правило
\textit{referencePointcut}, описывающее ссылку на другой срез.
Также различные узлы среза могут иметь знак инверсии, быть обернуты в круглые
скобки или же быть связанными друг с другом при помощи операций конъюнкции или
дизъюнкции.
%%TODO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Файл KotlinGrammar.g4}
\label{ssub:kotlin_grammar_g4}
%%TODO

Из файлов с описанием грамматики можно автоматически сгенерировать парсер на языке Java, который будет состоять из следующий классов:
\begin{itemize}
	\item \textit{AspectGrammarLexer} --- класс, содержащий в себе лексер
		  сгенерированной грамматики.
	\item \textit{AspectGrammarParser} --- класс, содержащий в себе парсер
		  сгенерированной грамматики.
	\item \textit{AspectGrammarVisitor} --- интерфейс, описывающий визитор для
		  парсинга.
	\item \textit{AspectGrammarListener} --- интерфейс, описывающий листенер
		  для парсинга.
	\item \textit{AspectGrammarBaseVisitor} --- базовый класс, реализующий
		  интерфейс \textit{AspectGrammarVisitor}.
	\item \textit{AspectGrammarBaseListener} --- базовый класс, реализующий
		  интерфейс \textit{AspectGrammarListener}.
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Разработка структуры прототипа}
\label{sub:aspect_weaving_part_development}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Для удобства, исходный код прототипа был разнесен между тремя пакетами:
\begin{itemize}
	\item \textit{models} --- пакет, содержащий классы, отвечающие за построение
		  модели аспектов.
	\item \textit{parsers} --- пакет, содержащий в себе парсеры (как
	сгенерированные из грамматики, описанной в разделе
	\ref{sub:aspect_grammar_part_development}, так и собственные классы для
	разбора описания аспектов).
	\item \textit{psi} --- пакет, содержащий в себе методы, отвечающие за
		  применение аспектов к целевой программе.
\end{itemize}
Ниже будет приведено описания файлов, содержащихся в данных пакетах.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Интерфейс BooleanExpression}
\label{ssub:BooleanExpression}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}[language=Java, label={lst:BooleanExpression},
  caption={Интерфейс BooleanExpression}]
interface BooleanExpression {
    fun calcExpression(
    	psiElement: PsiElement): Boolean
}
\end{lstlisting}

Интерфейс \textit{BooleanExpression} является базовым для дерева логического
выражения, составляемого для описания среза.
Данный интерфейс описывает метод \textit{calcExpression}, принимающий узел PSI и возвращающий, принадлежит ли данный узел к описанию среза или нет.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс Or}
\label{ssub:Or}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}[language=Java, label={lst:Or},
  caption={Класс Or}]
class Or(var left: BooleanExpression,
	var right: BooleanExpression) :
	BooleanExpression {
	...
    override fun calcExpression(
    	psiElement: PsiElement): Boolean {
        return left.calcExpression(psiElement) ||
        	right.calcExpression(psiElement)
    }
}
\end{lstlisting}

Данный класс предназначен для описания узла логического выражения,
соответствующего оператору дизъюнкции.
Класс наследуется от интерфейса \textit{BooleanExpression} и содержит двух
потомков \textit{left} и \textit{right}.
При вызове метода \textit{calcExpression}, метод возвращает результат вычисления
данного метода у потомков, соединенный операцией дизъюнкции.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс And}
\label{ssub:And}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}[language=Java, label={lst:And},
  caption={Класс And}]
class And(var left: BooleanExpression,
	var right: BooleanExpression) :
	BooleanExpression {
	...
    override fun calcExpression(
    	psiElement: PsiElement): Boolean {
        return left.calcExpression(psiElement) &&
        	right.calcExpression(psiElement)
    }
}
\end{lstlisting}

Данный класс предназначен для описания узла логического выражения,
соответствующего оператору конъюнкции.
Класс наследуется от интерфейса \textit{BooleanExpression} и содержит двух
потомков \textit{left} и \textit{right}.
При вызове метода \textit{calcExpression}, метод возвращает результат вычисления
данного метода у потомков, соединенный операцией конъюнкции.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс Not}
\label{ssub:Not}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}[language=Java, label={lst:Not},
  caption={Класс Not}]
class Not(var child: BooleanExpression) :
	BooleanExpression {
 ...
    override fun calcExpression(
    	psiElement: PsiElement): Boolean {
        return !child.calcExpression(psiElement)
    }
}
\end{lstlisting}

Данный класс предназначен для описания узла логического выражения,
соответствующего оператору инверсии.
Класс наследуется от интерфейса \textit{BooleanExpression} и содержит одного
потомка \textit{child}.
При вызове метода \textit{calcExpression}, метод возвращает инвертированный
результат вычисления данного метода у потомка.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Выводы}
\label{sec:development_conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
