%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Разработка прототипа аспектно-ориентированного расширения}
\label{ch:develop}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
В данном разделе рассматривается реализация прототипа в соответствии с
поставленными требованиями и разработанной архитектурой.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Средства разработки}
\label{sec:dev_tools}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Для разработки синтаксиса описания аспектов было решено использовать язык ANTLR4
про следующим причинам:
\begin{itemize}
	\item Данный язык позволяет достаточно компактно описывать грамматики и
		  генерировать парсеры по составленным грамматикам.
	\item Возможность генерации парсеров на языке Java.
	\item Существование грамматики описания аспектов на данном языке для
		  фреймворка AspectJ, синтаксис которого было решено взять за основу
		  разрабатываемой грамматики.
\end{itemize}

При разработке прототипа было решено использовать язык Kotlin.
Данный выбор был обусловлен следующими причинами:
\begin{itemize}
	\item Полная совместимость с языком Java и, как следствие, возможность
		  использовать библиотеки, разработанные для языка Java.
	\item Необходимость обеспечить достаточно высокую производительность, т.к.
		  целевые программы могут иметь достаточно большие размеры.
	\item Наличие опыта разработки на данном языке у автора работы, что
		  позволит уменьшить сроки разработки прототипа.
\end{itemize}
Разработка среды велась на языке Kotlin версии 1.0.6.
В качестве целевых программ также подразумеваются программы, написанные на языке Kotlin версии 1.0.6.

Сборка проекта производится при помощи фреймворка Apache Maven.
Данный фреймворк позволяет декларативным образом описывать проект сборки, а
также подключать сторонние библиотеки.
Одной из отличительных особенностей Maven является наличие центрального
репозитория, содержащего большое колличество библиотек, как для языка Java, так
и для языка Kotlin.
Вся информация о сборке (описание циклов сборки, подключаемые библиотеки и т.д.)
описывается в файле pom.xml (Project Object Model) в формате XML.
Еще одним критерием, по которому выбор был сделан в пользу Maven является наличие плагина, позволяющего компилировать программы на Kotlin.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Архитектура проекта}
\label{sec:project_structure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Проект можно разбить на три части: часть, отвечающая за построение PSI (компилятор Kotlin), часть отвечающая за описания синтаксиса и построение модели аспектов и часть, реализующая внедрение аспектов в целевую программу.
Ниже будет приведено описание процесса разработки двух вышеописанных частей.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Разработка грамматики аспектов}
\label{sub:aspect_grammar_part_development}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Для удобства, описание грамматики аспектов было разделено между двумя файлами:
\textit{AspectGrammar.g4} (исходный код приведен в листинге
\ref{listings:AspectGrammar}) и \textit{KotlinGrammar.g4} (исходный код
приведен в листинге \ref{listings:KotlinGrammar}).
В файле \textit{AspectGrammar.g4} описана чать грамматики, отвечающая за
грамматику непосредственно аспектов, как например, правила описания аспектов,
срезов, советов и т.д.
В файле \textit{KotlinGrammar.g4} содержится описание грамматики, относящейся к
языку Kotlin, например, стандартные типы языка, правила описания параметров
методов, модификаторы методов и т.д.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Файл AspectGrammar.g4}
\label{ssub:aspect_grammar_g4}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Точкой входа является правило \textit{aspectDeclaration} --- правило,
описывающее декларацию аспекта.
Данное правило включает в себя подправило \textit{aspectBody}, описывающее, в
свою очередь, тело аспекта, состоящее из открывающей и закрывающей фигурной
скобки между которыми находится ноль или более элементов, описанных в правиле
\textit{aspectBodyDeclaration}.
Правило \textit{aspectBodyDeclaration} может быть представлено или в виде
подправила \textit{advice}, описывающего совет, или в виде подправила
\textit{pointcut}, содержащего описание среза.

Правило описания совета содержит следующие составные части:
\begin{itemize}
	\item \textit{adviceSpec} --- спецификация совета, содержащая как позицию
		  внедрения кода совета относительно точки внедрения, так и список
		  параметров совета.
	\item Символ \quotes{:}, отделяющий спецификацию совета от описания среза.
	\item \textit{pointcutExpression} --- правило, содержащее описание среза.
	\item \textit{methodBody} --- правило, содержащее описание тела совета.
\end{itemize}
Код правила, описывающего совет приведен в листинге \ref{lst:advice_rule}:
\begin{lstlisting}[style={java}, label={lst:advice_rule},
  caption={Правило описания совета advice}]
advice
	:	adviceSpec ('throws' typeList)? ':' pointcutExpression methodBody
	;
\end{lstlisting}

Согласно правилу \textit{adviceSpec}, спецификация совета описывается по
следующему правилу: на первом месте находится ключевое слово, описывающее
способ внедрения аспекта, после чего в скобках следует список параметров, правило описания которых содержатся в правиле \textit{formalParameters},
используемых при построении срезов, а также внутри тела аспекта.
В случае, если необходимо применить код совета после возвращения методом
значения, то к спецификации совета добавляется ключевое слово
\textit{returning}, а также тип возвращаемого значения и его идентификатор, при
помощи которого можно обращаться к значению, возвращаемому функцией,
составляющей срез.
В случае, если необходимо применить код совета после возникновения
исключительной ситуации, то к спецификации совета добавляется ключевое слово
\textit{throwning}, а также тип перехватываемого исключения и идентификатор переменной.

Правило описания среза содержит следующие составные части:
\begin{itemize}
	\item Ключевое слово \quotes{pointcut}, сигнализирующее о том, что далее
		  будет следовать описание среза.
	\item Идентификатор среза \textit{id}, уникальный в рамках совета, при
		  помощи которого можно производить обращение к данному срезу из других
		  срезов.
	\item Список параметров, используемых в срезе и описывающихся при помощи
		  правила \textit{formalParameters}.
	\item Символ \quotes{:}, отделяющий спецификацию среза от его описания.
	\item Описание среза, формализованное внутри правила
		  \textit{pointcutExpression}.
	\item Символ \quotes{;}, сигнализирующий об окончании описания среза
		  (опциональный параметр).
\end{itemize}

Правило согласно которому производится описание срезов, представлено в листинге
\ref{lst:pointcut_expression_rule}:
\begin{lstlisting}[style={java}, label={lst:pointcut_expression_rule},
  caption={Правило описания среза pointcutExpression}]
pointcutExpression
  :  (pointcutPrimitive | referencePointcut)
  |  '!' pointcutExpression
  |  '(' pointcutExpression ')'
  |  pointcutExpression '&&' pointcutExpression
  |  pointcutExpression '||' pointcutExpression
  ;
\end{lstlisting}
Как видно из листинга \ref{lst:pointcut_expression_rule}, описание среза имеет
два терминальных правила: \textit{pointcutPrimitive}, описывающий одно из
правил среза (например, \quotes{call} или \quotes{execute}) или же правило
\textit{referencePointcut}, описывающее ссылку на другой срез.
Также различные узлы среза могут иметь знак инверсии, быть обернуты в круглые
скобки или же быть связанными друг с другом при помощи операций конъюнкции или
дизъюнкции.

Правило \textit{referencePointcut} описывается как идентификатор среза, на который производится ссылка и список параметров, которые могут использоваться в данном срезе.
Текстовое представление данного правила приведено в листинге~\ref{lst:referencePointcut_rule}:
\begin{lstlisting}[style={java}, label={lst:referencePointcut_rule},
  caption={Правило описания ссылки на другой срез referencePointcut}]
referencePointcut
  : id formalParametersPattern
  ;
\end{lstlisting}

Правило описания примитива среза \textit{pointcutPrimitive} приведено в листинге
\ref{lst:pointcutPrimitive_rule}:
\begin{lstlisting}[style={java}, label={lst:pointcutPrimitive_rule},
  caption={Правило описания ссылки на другой срез referencePointcut}]
pointcutPrimitive
  :  'call' '(' methodOrConstructorPattern ')'  #CallPointcut
  |  'execution' '(' methodOrConstructorPattern ')'  #ExecutionPointcut
  |  'target' '(' typeOrIdentifier ')'  #TargetPointcut
...
	;
\end{lstlisting}
Как видно из листинга, примитивы \textit{call} и \textit{execution} содержат в себе правило \textit{methodOrConstructorPattern}, описывающее метод.
Правило \textit{target} содержит в себе описание типа, на элементе которого должен быть вызван целевой метод.

Описание правила \textit{methodOrConstructorPattern} приведено в листинге \ref{lst:methodOrConstructorPattern_rule}:
\begin{lstlisting}[style={java}, label={lst:methodOrConstructorPattern_rule},
  caption={Правило methodOrConstructorPattern}]
methodOrConstructorPattern
	:	methodPattern
	|	constructorPattern
	;
\end{lstlisting}
Как видно из листинга, данное правило содержит в себе правило описания двух правил: \textit{methodPattern}, описывающее метод и \textit{constructorPattern},
описывающее конструктор.

Код правила \textit{methodPattern} приведен в листинге \ref{lst:methodPattern_rule}:
\begin{lstlisting}[style={java}, label={lst:methodPattern_rule},
  caption={Правило methodPattern}]
methodPattern
	:	annotationPattern? methodModifiersPattern? extensionModifier? inlineModifier? 'fun' (typePattern dotOrDotDot)? simpleNamePattern formalParametersPattern (':' retTypePattern)?
	;
\end{lstlisting}
Данное правило состоит из нескольких правил:
\begin{itemize}
	\item \textit{annotationPattern}~--- правило, описывающее аннотации метода;
	\item \textit{methodModifiersPattern}~--- правило, описывающее модификаторы метода;
	\item \textit{extensionModifier}~--- правило позволяющее задать является ли метод extension методом или нет;
	\item \textit{inlineModifier}~--- правило позволяющее задать является ли данный метод inline методом или нет;
	\item Ключевое слово \quotes{fun};
	\item \textit{typePattern dotOrDotDot}~--- набор правил, позволяющий задать пакет и класс, к которому относится метод;
	\item \textit{simpleNamePattern}~--- правило, позволяющее задать идентификатор метода;
	\item \textit{formalParametersPattern}~--- правило, позволяющее задать список параметров метода;
	\item \textit{retTypePattern}~--- правило, позволяющее задать тип возвращаемого методом значения.
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Файл KotlinGrammar.g4}
\label{ssub:kotlin_grammar_g4}
В данном файле описаны правила языка Kotlin, необходимые для задания аспектов.
Первом таким правилом является правило \textit{typeType}, представленное в листинге \ref{lst:typeType_rule}:
\begin{lstlisting}[style={java}, label={lst:typeType_rule},
  caption={Правило typeType}]
typeType
    :   classOrInterfaceType nullabilityModifier?
    |   primitiveType nullabilityModifier?
    ;
\end{lstlisting}
Согласно данному правилу, тип может быть как пользовательским (правило \textit{classOrInterfaceType}) или же стандартным (правило \textit{primitiveType}).
Любой из этих типов может иметь модификатор, указывающий на то, что аргумент данного типа может принимать значение \textit{null}.

Правило \textit{primitiveType}, описывающее примитивные типы языка Kotlin, приведены в листинге \ref{lst:primitiveType_rule}:
\begin{lstlisting}[style={java}, label={lst:primitiveType_rule},
  caption={Правило primitiveType}]
primitiveType
    :   'Double'
    |   'Float'
    |   'Long'
    |   'Int'
    |   'Short'
    |   'Byte'
    |   'Any'
    ;
\end{lstlisting}
Как видно из листинга, к стандартным типам языка Kotlin был также добавлен тип \quotes{Any}, который используется в языке Kotlin для того, чтобы указать, что в качестве аргумента можно передать любой тип.

Правило \textit{classOrInterfaceType} задает способ описания пользовательских типов.
Код правила приведен в листинге \ref{lst:classOrInterfaceType_rule}:
\begin{lstlisting}[style={java}, label={lst:classOrInterfaceType_rule},
  caption={Правило classOrInterfaceType}]
classOrInterfaceType
    :   Identifier typeArguments? ('.' Identifier typeArguments? )*
    ;
\end{lstlisting}
Как видно из листинга, правило описывающее имя класса состоит из идентификатора класса, а также необязательного списка аргументов типа (правило \textit{typeArguments}), которые могут повторяться от 1 до бесконечности раз, разделяясь символом \quotes{.}.

Модификаторы метода перечисленны в правиле \textit{methodModifier} (листинг \ref{lst:methodModifier_rule}):
\begin{lstlisting}[style={java}, label={lst:methodModifier_rule},
  caption={Правило methodModifier}]
methodModifier
	:	(	'public'
		|	'private'
		|	'protected'
		|	'internal'
		|	'inline'
		|	'synchronized'
		|	'open'
		|	'override'
		)
	;
\end{lstlisting}

Правило \textit{formalParameter} описывает способ задания параметров при описании совета (листинг \ref{lst:formalParameter_rule}):
\begin{lstlisting}[style={java}, label={lst:formalParameter_rule},
  caption={Правило formalParameter}]
formalParameter
    :   variableDeclaratorId ':' typeType
    ;
\end{lstlisting}
Как видно из листинга, параметры задаются следующим образом: первым идет описание типа, затем символ \quotes{:}, а после него следует идентификатор параметра.

Из файлов с описанием грамматики можно автоматически сгенерировать парсер на языке Java, который будет состоять из следующий классов:
\begin{itemize}
	\item \textit{AspectGrammarLexer} --- класс, содержащий в себе лексер
		  сгенерированной грамматики.
	\item \textit{AspectGrammarParser} --- класс, содержащий в себе парсер
		  сгенерированной грамматики.
	\item \textit{AspectGrammarVisitor} --- интерфейс, описывающий визитор для
		  парсинга.
	\item \textit{AspectGrammarListener} --- интерфейс, описывающий листенер
		  для парсинга.
	\item \textit{AspectGrammarBaseVisitor} --- базовый класс, реализующий
		  интерфейс \textit{AspectGrammarVisitor}.
	\item \textit{AspectGrammarBaseListener} --- базовый класс, реализующий
		  интерфейс \textit{AspectGrammarListener}.
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Разработка структуры прототипа}
\label{sub:aspect_weaving_part_development}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Для удобства, исходный код прототипа был разнесен между тремя пакетами:
\begin{itemize}
	\item \textit{models} --- пакет, содержащий классы, отвечающие за построение
		  модели аспектов.
	\item \textit{parsers} --- пакет, содержащий в себе парсеры (как
	сгенерированные из грамматики, описанной в разделе
	\ref{sub:aspect_grammar_part_development}, так и собственные классы для
	разбора описания аспектов).
	\item \textit{psi} --- пакет, содержащий в себе методы, отвечающие за
		  применение аспектов к целевой программе.
\end{itemize}
Ниже будет приведено описания файлов, содержащихся в данных пакетах.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Интерфейс BooleanExpression}
\label{ssub:BooleanExpression}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Интерфейс \textit{BooleanExpression} является базовым для дерева логического
выражения, составляемого для описания среза.
Данный интерфейс описывает метод \textit{calcExpression}, принимающий узел PSI и возвращающий, принадлежит ли данный узел к описанию среза или нет.

\begin{lstlisting}[style={java}, label={lst:BooleanExpression},
  caption={Интерфейс BooleanExpression}]
interface BooleanExpression {
    fun calcExpression(psiElement: PsiElement): Boolean
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс Or}
\label{ssub:Or}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Класс \textit{Or} предназначен для описания узла логического выражения,
соответствующего оператору дизъюнкции.
Класс наследуется от интерфейса \textit{BooleanExpression} и содержит двух
потомков \textit{left} и \textit{right}.
При вызове метода \textit{calcExpression}, метод возвращает результат вычисления
данного метода у потомков, соединенный операцией дизъюнкции.

\begin{lstlisting}[style={java}, label={lst:Or},
  caption={Класс Or}]
class Or(val left: BooleanExpression, val right: BooleanExpression) :
	BooleanExpression {
	...
    override fun calcExpression(psiElement: PsiElement): Boolean {
        return left.calcExpression(psiElement) ||
        	right.calcExpression(psiElement)
    }
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс And}
\label{ssub:And}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Класс \textit{And} предназначен для описания узла логического выражения,
соответствующего оператору конъюнкции.
Класс наследуется от интерфейса \textit{BooleanExpression} и содержит двух
потомков \textit{left} и \textit{right}.
При вызове метода \textit{calcExpression}, метод возвращает результат вычисления
данного метода у потомков, соединенный операцией конъюнкции.

\begin{lstlisting}[style={java}, label={lst:And},
  caption={Класс And}]
class And(val left: BooleanExpression, val right: BooleanExpression) :
	BooleanExpression {
	...
    override fun calcExpression(psiElement: PsiElement): Boolean {
        return left.calcExpression(psiElement) &&
        	right.calcExpression(psiElement)
    }
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс Not}
\label{ssub:Not}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Класс \textit{Not} предназначен для описания узла логического выражения,
соответствующего оператору инверсии.
Класс наследуется от интерфейса \textit{BooleanExpression} и содержит одного
потомка \textit{child}.
При вызове метода \textit{calcExpression}, метод возвращает инвертированный
результат вычисления данного метода у потомка.

\begin{lstlisting}[style={java}, label={lst:Not},
  caption={Класс Not}]
class Not(val child: BooleanExpression) :
	BooleanExpression {
 ...
    override fun calcExpression(psiElement: PsiElement): Boolean {
        return !child.calcExpression(psiElement)
    }
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс AspectItem}
\label{ssub:AspectItem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Абстрактный класс \textit{AspectItem} реализует интерфейс
\textit{BooleanExpression} и является базовым классом для всех классов,
представляющих сигнатуры в описании срезов.
Класс содержит поле \textit{key}, хранящее в себе уникальный идентификатор
элемента класса (в рамках данной реализации в качестве ключа был выбран хэш
объекта).

\begin{lstlisting}[style={java}, label={lst:AspectItem},
  caption={Класс AspectItem}]
abstract class AspectItem : BooleanExpression {
    val key = this.hashCode()
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс CallNodeItem}
\label{ssub:CallNodeItem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Класс \textit{CallNodeItem} наследуется от абстрактного класса
\textit{AspectItem} и предназначен для представления терминального узла
описания среза, соответствующего сигнатуре \textit{call}.
Данный класс содержит поле \textit{methodPattern}, хранящее представление
описания метода.

\begin{lstlisting}[style={java}, label={lst:CallNodeItem},
  caption={Класс CallNodeItem}]
class CallNodeItem(val methodPattern: MethodPattern) : AspectItem() {
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс ExecutionNodeItem}
\label{ssub:ExecutionNodeItem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Класс \textit{ExecutionNodeItem} наследуется от абстрактного класса
\textit{AspectItem} и предназначен для представления терминального узла
описания среза, соответствующего сигнатуре \textit{execution}.
Данный класс содержит поле \textit{methodPattern}, хранящее представление
описания метода.

\begin{lstlisting}[style={java}, label={lst:ExecutionNodeItem},
  caption={Класс ExecutionNodeItem}]
class ExecutionNodeItem(val methodPattern: MethodPattern)
	: AspectItem() {
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс ReferencePointcutNodeItem}
\label{ssub:ReferencePointcutNodeItem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Класс \textit{ReferencePointcutNodeItem} наследуется от абстрактного класса
\textit{AspectItem} и предназначен для представления терминального узла
описания среза, соответствующего ссылке на другой срез.
Данный класс содержит поле \textit{identifier}, хранящее идентификатор среза,
на которого происходит ссылка и поле \textit{referencePointcutKey}, хранящее
идентификатор целевого среза.

\begin{lstlisting}[style={java}, label={lst:ReferencePointcutNodeItem},
  caption={Класс ReferencePointcutNodeItem}]
class ReferencePointcutNodeItem(val identifier: String,
	var referencePointcutKey: Int) : AspectItem() {
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс TargetNodeItem}
\label{ssub:TargetNodeItem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Класс \textit{TargetNodeItem} наследуется от абстрактного класса
\textit{AspectItem} и предназначен для представления терминального узла
описания среза, соответствующего сигнатуре \textit{target}.
Данный класс содержит поле \textit{type} типа \textit{ArgumentModel}, хранящее
в себе тип, указанный в сигнатуре \textit{target}, а также идентификатор
переменной, при помощи которого можно производить обращение к элементу на
котором производится вызов метода внутри кода совета.

\begin{lstlisting}[style={java}, label={lst:TargetNodeItem},
  caption={Класс TargetNodeItem}]
class TargetNodeItem(val type: ArgumentModel) : AspectItem() {
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс ArgumentModel}
\label{ssub:ArgumentModel}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Класс \textit{ArgumentModel} предназначен для представления аргументов совета и
среза, а также для хранения типа и идентификатора переменной при использовании
правила \textit{target}.
Данный класс содержит поле \textit{argumentType}, хранящее в себе тип аргумента
и \textit{identifier}, содержащее идентификатор аргумента.

\begin{lstlisting}[style={java}, label={lst:ArgumentModel},
  caption={Класс ArgumentModel}]
class ArgumentModel(val argumentType: ParameterModel,
	val identifier: String) {
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Перечисление NullabilityType}
\label{ssub:NullabilityType}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Перечисление \textit{NullabilityType} предназначено для хранения Nullability 
аргумента.
Перечисление имеет следующие значения:
\begin{itemize}
	\item \textit{NULLABLE}~--- аргумент может принимать значения null;
	\item \textit{NOT\_NULL}~--- аргумент может принимать только не null
		  значения;
	\item \textit{ANYTHING}~--- не имеет разницы, какие значения может
		  принимать аргумент.
\end{itemize}

\begin{lstlisting}[style={java}, label={lst:NullabilityType},
  caption={Перечисление NullabilityType}]
enum class NullabilityType {
    NULLABLE,
    NOT_NULL,
    ANYTHING
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс MaybeNegativeModel}
\label{ssub:MaybeNegativeModel}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Класс \textit{MaybeNegativeModel} предназначен для хранения элементов, которые
могут быть заданы со знаком инверсии.
Класс имеет следующие поля:
\begin{itemize}
	\item \textit{name}~--- имя;
	\item \textit{negative}~--- флаг, сигнализирующий о том, используется ли
		  инверсия при задании типа или нет (по умолчанию имеет значение
		  \textit{false}).
\end{itemize}

\begin{lstlisting}[style={java}, label={lst:MaybeNegativeModel},
  caption={Класс MaybeNegativeModel}]
open class MaybeNegativeModel(var name: String = "",
                              var negative: Boolean = false) {
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс ParameterModel}
\label{ssub:ParameterModel}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Класс \textit{ParameterModel} предназначено для хранения типа, наследуется от
класса \textit{MaybeNegativeModel}.
Класс имеет следующие поля:
\begin{itemize}
	\item \textit{name}~--- имя типа;
	\item \textit{negative}~--- флаг, сигнализирующий о том, используется ли
		  инверсия при задании типа или нет (по умолчанию имеет значение
		  \textit{false});
	\item \textit{packageName}~--- имя пакета;
	\item \textit{nullableModifier}~--- nullability модификатор типа (по
		  умолчанию ANYTHING);
	\item \textit{parameterList}~--- список параметров, в случае если параметр является generic классом.
\end{itemize}

\begin{lstlisting}[style={java}, label={lst:ParameterModel},
  caption={Класс ParameterModel}]
class ParameterModel(name: String = "",
                     negative: Boolean = false,
                     var packageName : String = "",
                     val nullableModifier: NullabilityType = NullabilityType.ANYTHING,
                     val parameterList :List<ParameterModel> = listOf()): MaybeNegativeModel(name, negative) {
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс Pointcut}
\label{ssub:Pointcut}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Класс \textit{Pointcut} является наследником класса \textit{AspectItem} и
предназначен для хранения модели среза.
Класс имеет два поля: \textit{id}, хранящее идентификатор среза и
\textit{pointcutExpression}, хранящее в себе описание среза.

\begin{lstlisting}[style={java}, label={lst:Pointcut},
  caption={Класс Pointcut}]
class Pointcut(val id: String,
	val pointcutExpression: BooleanExpression) : AspectItem() {
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс Advice}
\label{ssub:Advice}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Абстрактный класс \textit{Advice} является наследником класса
\textit{AspectItem} и предназначен для хранения модели совета.
Класс имеет следующие поля:
\begin{itemize}
	\item \textit{pointcutExpression}~--- описание среза совета;
	\item \textit{adviceCode}~--- строка, хранящая в себе код совета;
	\item \textit{parameterList}~--- список параметров совета;
	\item \textit{pointcutList}~--- список срезов, объявленных в рамках аспекта.
\end{itemize}

Также данный класс имеет абстрактный метод \textit{wrapPointcut},
предназначенный для добавления кода совета к точке внедрения.

\begin{lstlisting}[style={java}, label={lst:Advice},
  caption={Класс Advice}]
abstract class Advice(val pointcutExpression: BooleanExpression,
                  val adviceCode: String,
                  val parameterList: List<ArgumentModel>,
                  val pointcutList : List<Pointcut>) : AspectItem() {
	abstract fun wrapPointcut(pointcutStr: String,
		targetIdentifier: String): String
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс AfterAdvice}
\label{ssub:AfterAdvice}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Класс \textit{AfterAdvice} наследуется от абстрактного класса \textit{Advice} и
предназначен для модели совета, осуществляющего внедрение кода совета после
точки объединения.
Класс содержит поля, аналогичные полям класса \textit{Advice}.

\begin{lstlisting}[style={java}, label={lst:AfterAdvice},
  caption={Класс AfterAdvice}]
class AfterAdvice(pointcutExpression: BooleanExpression,
                  adviceCode: String,
                  parameterList: List<ArgumentModel>,
                  pointcutList: List<Pointcut>):
                  Advice(pointcutExpression, adviceCode, parameterList, pointcutList) {
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс AroundAdvice}
\label{ssub:AroundAdvice}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Класс \textit{AroundAdvice} наследуется от абстрактного класса \textit{Advice} и
предназначен для модели совета, осуществляющего внедрение кода совета вместо
точки объединения.
Класс содержит поля, аналогичные полям класса \textit{Advice}.

\begin{lstlisting}[style={java}, label={lst:AroundAdvice},
  caption={Класс AroundAdvice}]
class AroundAdvice(pointcutExpression: BooleanExpression,
                   adviceCode: String,
                   parameterList: List<ArgumentModel>,
                   pointcutList: List<Pointcut>) : Advice(pointcutExpression, adviceCode, parameterList, pointcutList) {
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс BeforeAdvice}
\label{ssub:BeforeAdvice}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Класс \textit{BeforeAdvice} наследуется от абстрактного класса \textit{Advice} и
предназначен для модели совета, осуществляющего внедрение кода совета до
точки объединения.
Класс содержит поля, аналогичные полям класса \textit{Advice}.

\begin{lstlisting}[style={java}, label={lst:BeforeAdvice},
  caption={Класс BeforeAdvice}]
class BeforeAdvice(pointcutExpression: BooleanExpression,
                   adviceCode: String,
                   parameterList: List<ArgumentModel>,
                   pointcutList: List<Pointcut>): Advice(pointcutExpression, adviceCode, parameterList, pointcutList) {
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс Aspect}
\label{ssub:Aspect}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Класс \textit{Aspect} предназначен для хранения модели аспекта.
Данный класс имеет следующие поля:
\begin{itemize}
	\item \textit{id}~--- идентификатор аспекта;
	\item \textit{pointcuts}~--- список срезов, объявленных внутри аспекта;
	\item \textit{advices}~--- список советов, объявленных внутри аспекта.
\end{itemize}

\begin{lstlisting}[style={java}, label={lst:Aspect},
  caption={Класс Aspect}]
class Aspect(val id: String,
	val pointcuts: List<Pointcut>,
	val advices: List<Advice>)
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс PointcutVisitor}
\label{ssub:PointcutVisitor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Класс \textit{PointcutVisitor} реализует паттерн \quotes{Посетитель} и
предназначен для построения моделей именованных срезов, хранящихся в списке
\textit{pointcuts}.
Данный класс является наследником класса \textit{AspectGrammarBaseVisitor}.

\begin{lstlisting}[style={java}, label={lst:PointcutVisitor},
  caption={Класс PointcutVisitor}]
class PointcutVisitor : AspectGrammarBaseVisitor<Pointcut>() {
    val pointcuts = mutableListOf<Pointcut>()
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс AdviceVisitor}
\label{ssub:AdviceVisitor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Класс \textit{AdviceVisitor} реализует паттерн \quotes{Посетитель} и
предназначен для построения моделей советов, хранящихся в списке
\textit{advices}.
Также класс принимает список существующих в рамках данного аспекта срезов в качестве параметра \textit{pointcutList}.
Данный класс является наследником класса \textit{AspectGrammarBaseVisitor}.

\begin{lstlisting}[style={java}, label={lst:AdviceVisitor},
  caption={Класс AdviceVisitor}]
class AdviceVisitor(val pointcutList: MutableList<Pointcut>) : AspectGrammarBaseVisitor<Advice>() {
    var advices = mutableListOf<Advice>()
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс AdviceVisitor}
\label{ssub:AdviceVisitor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Класс \textit{AspectVisitor} реализует паттерн \quotes{Посетитель} и
предназначен для построения модели аспекта.
Данный класс является наследником класса \textit{AspectGrammarBaseVisitor}.

\begin{lstlisting}[style={java}, label={lst:AspectVisitor},
  caption={Класс AspectVisitor}]
class AspectVisitor : AspectGrammarBaseVisitor<Aspect>() {
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Файл utils}
\label{ssub:utils}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
В файле \textit{utils.kt} содержится набор служебных методов, используемых при
составлении моделей срезов и советов.
Файл содержит следующие методы:
\begin{itemize}
	\item \textit{buildSimpleType(typeContext: AspectGrammarParser.\\TypePatternContext?): ParameterModel}~--- метод, предназначенный для построения модели простого типа;
	\item \textit{buildPackage(context: ParserRuleContext): String}~--- метод, предназначенный для построения имени пакета метода;
	\item \textit{buildType(typeContext: ParserRuleContext?): ParameterModel}~--- метод, предназначенный для составления полного типа;
	\item \textit{buildPointcutExpression(pointcutExpression: AspectGrammarParser.PointcutExpressionContext, paramList: AspectGrammarParser.FormalParameterListContext?): BooleanExpression}~--- метод для построения дерева, соответствующего описанию среза;
	\item \textit{pointcutExpression(pointcutExpression: AspectGrammarParser.\\PointcutExpressionContext, paramList: AspectGrammarParser.\\FormalParameterListContext?): BooleanExpression}~--- метод для составления выражения, соответствующего узлу дерева;
	\item \textit{buildModifiersList(modifier: AspectGrammarParser.\\MethodModifiersPatternContext?): MutableList<\\MaybeNegativeModel>}~--- метод, предназначенный для построения списка модификаторов метода;
	\item \textit{fillMethod(methodPattern: AspectGrammarParser.\\MethodPatternContext): MethodPattern}~--- выражение для построения модели описания метода.
	\item \textit{fun parseFile(fileName: String): Aspect}~--- метод, предназначенный для инициализации построения модели аспекта.
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Класс BaseTagSetter}
\label{ssub:BaseTagSetter}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Класс \textit{BaseTagSetter} является абстрактным классом для классов, осуществляющих разметку PSI тегами, соответствующим срезам.
Данный класс определяет два абстрактных метода:
\begin{itemize}
	\item \textit{setTag(psiElement: PsiElement, aspectItem: AspectItem)}~--- метод, определяющий правила разметки узла PSI;
	\item \textit{visitFile(file: KtFile, aspectItem: AspectItem)}~--- метод, определяющий правила анализа файла, например выбор из множества узлов PSI потенциальных кандидатов, соответствующих срезу.
\end{itemize}
\begin{lstlisting}[style={java}, label={lst:BaseTagSetter},
  caption={Класс BaseTagSetter}]
abstract class BaseTagSetter {
    abstract fun setTag(psiElement: PsiElement, aspectItem: AspectItem)

    abstract fun visitFile(file: KtFile, aspectItem: AspectItem)

...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Объект CallPsiTagSetter}
\label{ssub:CallPsiTagSetter}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Объект \textit{CallPsiTagSetter} является наследником абстрактного класса
\textit{BaseTagSetter} и предназначен для разметки узлов, соответствующих сигнатуре \textit{call}.

\begin{lstlisting}[style={java}, label={lst:CallPsiTagSetter},
  caption={Объект CallPsiTagSetter}]
object CallPsiTagSetter : BaseTagSetter() {
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Объект ExecutePsiTagSetter}
\label{ssub:ExecutePsiTagSetter}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Объект \textit{ExecutePsiTagSetter} является наследником абстрактного класса
\textit{BaseTagSetter} и предназначен для разметки узлов, соответствующих сигнатуре \textit{execution}.

\begin{lstlisting}[style={java}, label={lst:ExecutePsiTagSetter},
  caption={Объект ExecutePsiTagSetter}]
object ExecutePsiTagSetter : BaseTagSetter() {
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Объект TargetPsiTagSetter}
\label{ssub:TargetPsiTagSetter}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Объект \textit{TargetPsiTagSetter} является наследником абстрактного класса
\textit{BaseTagSetter} и предназначен для разметки узлов, соответствующих сигнатуре \textit{target}.

\begin{lstlisting}[style={java}, label={lst:TargetPsiTagSetter},
  caption={Объект TargetPsiTagSetter}]
object TargetPsiTagSetter : BaseTagSetter() {
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Объект PointcutTagSetter}
\label{ssub:PointcutTagSetter}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Объект \textit{PointcutTagSetter} предназначен для разметки PSI тегами, соответствующим тегам срезов совета.

\begin{lstlisting}[style={java}, label={lst:PointcutTagSetter},
  caption={Объект PointcutTagSetter}]
object PointcutTagSetter {
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Объект AdviceWeaver}
\label{ssub:AdviceWeaver}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Объект \textit{AdviceWeaver} предназначен для реализации применения кода совета
к точке внедрения.
\begin{lstlisting}[style={java}, label={lst:AdviceWeaver},
  caption={Объект AdviceWeaver}]
object AdviceWeaver {
...
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Объект TargetProjectContainer}
\label{ssub:TargetProjectContainer}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Объект \textit{TargetProjectContainer} предназначен для хранения информации о проекте, используемой при анализе и модификации PSI.
К такой информации относится:
\begin{itemize}
	\item Экземпляр проекта, хранящийся в поле \textit{project};
	\item Экземпляр контекста, хранящийся в поле \textit{context};
	\item Ключ, под которым сохраняются теги в узлах PSI, хранящийся в поле \textit{tagKey}.
\end{itemize}
\begin{lstlisting}[style={java}, label={lst:TargetProjectContainer},
  caption={Объект TargetProjectContainer}]
object TargetProjectContainer {
    var project: Project? = null
    var context: BindingContext? = null
    val tagKey: Key<MutableList<Int>> = Key("aspectTagKey")
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Выводы}
\label{sec:development_conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
В результате был разработан прототип приложения в соответствии со сформулированными требованиями.

Была разработана грамматика аспектов для языка Kotlin на основе грамматики,
используемой в фреймворке AspectJ.
Для адаптации грамматики, используемой в AspectJ были изменены способы описания аргументов, примитивные типы языка, добавлены модификаторы, специфичные для языка Kotlin, а также ряд других изменений.

Реализован модуль, осуществляющий построение модели аспектов, последующее
применение к PSI программы.
Для компиляции полученного PSI была написана оболочка вокруг компилятора языка Kotlin.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
