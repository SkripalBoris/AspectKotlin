%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Обзор существующих аспектно-ориентированных расширений}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Описание аспектно-ориентированного подхода}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Подход, описывающий принципы аспектно-ориентированного программирования, был
предложен группой инженеров исследовательского центра Xerox PARC под
руководством Грегора Кичалеса~\cite{kiczales_aop}.
В данной работе были описаны сложности использования ООП при внедрении сквозной
функциональности в код, а так же было предложено выносить сквозную
функциональность в некоторую отдельную сущность --- \quotes{аспект}, для
последующего внедрения в код целевой программы.
На данном этапе были сформулированы основные идеи развития АОП, а также приведен
пример прототипа языка для описания аспектов.

Позднее, в своей статье \quotes{An Overview of AspectJ}~\cite{kiczales_aspectj},
Грегор Кичалес со своей научной группой представили более детальное и подробное
описание аспектов, а также расширение, позволяющее реализовывать аспекты для
языка Java --- AspectJ.
В данной работе были не только было представлено более детальное описание такой
сущности, как \quotes{аспект}, а так же описан синтаксис языка для описания
аспектов и способ внедрения аспектов в код программы.

Под аспектом понимается некоторая сущность, содержащая в себе не только описание
сквозной функциональности, но и правила её добавления в программный код, а
также, возможно, дополнительные функции и (или) переменные.
Сквозная функциональность, внутри аспекта, содержится в сущности, называемой
\quotes{совет} (advice).
Кроме этого, совет содержит описание среза (pointcut), согласно которому
происходит поиск \quotes{точек включения} (join points) в программе и применение
совета согласно некоторым правилам, которые тоже, как правило, описываются
внутри совета.
Для того, чтобы описание срезов было более компактным, а так же чтобы избежать
дублирования когда, правила для среза иногда разбивают на части, при этом каждая
из частей имеет уникальный (в рамках аспекта) идентификатор, который можно
вызывать как при описании советов, так и при описании других срезов.
После этого, на основе срезов, в целевую программу, по некоторым правилам,
внедряется код совета.
Можно выделить следующие способы внедрения кода советов относительно точки
объединения~\footnote{Возможны другие способы внедрения кода советов
относительно точек объединения, однако, данный список способов внедрения
реализуется в большинстве существующих аспектно-ориентированных расширений}:
\begin{itemize}
  \item Before --- вставка кода совета перед точкой объединения;
  \item After --- вставка кода совета после точки объединения;
  \item Afterreturning --- вставка кода совета после возвращения значения;
  \item Afterthrowning --- вставка кода совета после возникновения исключения
    (тип исключения, как правило, задается при описании совета);
  \item Around --- вставка кода совета до и после точки объединения.
\end{itemize}

Для составления срезов также используется ряд правил поиска, которые могут
комбинироваться между собой при помощи логических операторов \quotes{и},
\quotes{или}, \quotes{не}, а так же вызываться друг другом.
Набор ключевых слов для описания срезов в различных библиотеках отличается, но,
как правило основными примитивами являются:
%%TODO
\begin{itemize}
  \item Выполнение функции;
  \item Вызов функции;
  \item Обработка определенной исключительной ситуации;
  \item Поток управления.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Способы внедрения советов}
\label{sec:aspect_weaving}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
На данный момент можно выделить два основных способа внедрения сквозной
функциональности в программный продукт: статическое и динамическое связывание~
\cite{static_and_dynamic_AOP}.
Статический подход подразумевает связывание целевой программы и сквозной
функциональности на этапе в процессе построения, в то время как при динамическом
подходе, связывание программного продукта и сквозной функциональности происходит
только в момент исполнения программы.

При использовании статического подхода, внедрение сквозной функциональности
может происходить на одном из трех этапов:
\begin{enumerate}
  \item Перед компиляцией исходных кодов;
  \item Во время процесса компиляции;
  \item Сразу после компиляции исходных кодов.
\end{enumerate}

При динамическом способе внедрения аспектов, как правило, используются
объекты-посредники proxy)~\cite{aspect_dynamic_weavers}, имеющие такой же
интерфейс, что и класс, к которому он привязывается.
Данные объекты перехватывают обращения к соответствующим классом, тем самым
предоставляют возможность выполнять необходимый код до или после вызова целевого
метода.
Для внедрения кода советов используется отдельный класс, так называемый
\quotes{модератор аспектов} хранящий в себе список всех описанных аспектов.
При перехвате вызова, прокси-объект использует модератор аспектов для поиска
советов, которые соответствуют данному вызову.
Если совет не обнаруживается среди зарегистрированных советов, то данный совет
создается и регистрируется в объекте-модераторе, после чего производится вставка
кода совета.
При использовании данного подхода, выигрыш в производительности получается за
счет повторного использования когда советов.
Однако, из-за того, что абстрактные классы и виртуальные функции, используемые
при данном подходе, требуют много ресурсов, использование прокси-объектов может
сильно замедлить работу системы.

Посредник имеет тот же интерфейс, что и исходный класс, но он не вызывает 
сразу же метод объекта, реализующий класс Callee, есть возможность 
совершить дополнительные действия как до момента вызова (Before Advice), 
так и после него (AfterAdvice).

Для ряда языков, работающих поверх JVM возможен еще один способ динамического
применения аспектов - при загрузке байт кода программы в JVM~
\cite{aspect_dynamic_weavers_in_oop}.
Одним из таких подходов является Binary Component Adaptation (BCA)~\cite{bca},
позволяющий изменять байт-код программы в момент её загрузки, при помощи
подмены стандартного загрузчика классов виртуальной машины Java.
BCA использует дельта-файл для определения изменений, которые необходимо
произвести при загрузке байт-кода Java в виртуальную машину.
Дельта-файл предоставляет из себя с байт-кодом, расширенный рядом дополнительных
ключевых слов, описывающих трансформации байт-кода, как, например,
переименование методов и полей классов, добавление и удаление частей байт-кода,
а также ряд других трансформаций.
JVM выполняет преобразованный код так, как если бы он содержал новые или
переименованные методы.

%\begin{figure}[htbp]
%\centering
%\includegraphics[width=\textwidth]{how-to-do-the-actual-research}
%\caption{Рекомендации по проведению исследований в рамках диссертации}%
%\label{fig:how-to-do-research}
%\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Обзор существующих аспектно-ориентированных расширений}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{AspectJ}
\label{sub:aspectj_overwiev}

AspectJ --- аспектно-ориентированное расширение для языка Java, представленое в
2003 году Грегором Кичалесом~\cite{kiczales_aspectj} и разрабатываемое до сих
пор.
В данный момент разработкой данного расширения занимается компания Eclipse,
которая распространяет его под свободной лицензией EPL.
\nomenclature{EPL}{Eclipse Public License}

AspectJ поддерживает несколько способов внедрения кода советов --- статический и
динамический.
Статическое внедрение советов может производиться двумя способами: при помощи
изменения исходных кодов программы непосредственно перед компиляцией программы
или сразу после, путем модификации байт-кода.
По умолчанию используется второй способ, так как байт-код, как правило гораздо
легче поддается анализу, а также данный способ освобождает от необходимости
заботиться о целостности исходных кодов после применения аспектов.
Динамическое внедрение аспектов производится в момент загрузки файлов в JVM
(подробнее данный способ внедрения описан в разделе~\ref{sec:aspect_weaving}).

AspectJ расширяет грамматику языка Java, предоставляя ряд ключевых слов и
конструкций для описания аспектов.
По своей сути, аспект в терминологии AspectJ имеет много общего с классом, в
Java --- он также может содержать переменные и функции, однако, в его описании
присутствуют описания срезов и советов.
Описание аспекта начинается с ключевого слова \textit{aspect}, после чего
следует его идентификатор и тело.

Описание среза начинается с ключевого слова \textit{pointcut}, после чего
следует его параметры и идентификатор.
Для описания срезов, в AspectJ предусмотрен ряд ключевых слов:
  \begin{itemize}
    \item execution --- точкой включения является исполнение метода, 
      например, execution(void Point.setX(int)) показывает, что точкой 
      включения будет место исполнения метода setX класса Point, который 
      принимает один параметр типа int и возвращает void.
    \item call --- точкой включения является вызов метода, например, 
      call(void Point. setX(int)) показывает, что точкой 
      включения будет место вызова метода setX класса Point, который 
      принимает один параметр типа int и возвращает void.
    \item handler --- место обработки исключения, например, 
      handler( Array Out Of Bounds Exception) показывает, что точкой 
      включения будут все места обработки исключения Array Out Of Bounds 
      Exception.
    \item this --- точка, когда исполняемый объект имеет некоторый тип, 
      например, this(Some Type) показывает, что точкой включения будут все 
      точки, соответствующие типу Some Type.
    \item target --- когда целевой объект имеет некоторых тип, например 
      target(Some Type) показывает, что точкой включения будут точки, когда 
      целевым объектом является объект типа Some Type.
    \item within --- исполняемый код внутри класса (пакета, подпакетов), 
      например, within(MyClass) показывает, что точками включения будут все 
      методы класса MyClass.
    \item cflow --- совпадает со всеми точками соединения, встречающимися в 
      потоке выполнения заданного среза, например, cflow(call(void 
      Test.main())), показывает, что точками включения будут все точки, 
      внутри потока исполнения функции main без аргументов, класса Test, 
      которая возвращает void.
  \end{itemize}
Данные параметры так же можно комбинировать при помощи операторов \&\& (и), 
|| (или), ! (не).
  
Совет не имеет собственного идентификатора и его описание начинается с
ключевого слова, определяющего место внедрения кода совета относительно среза,
например:
  \begin{itemize}
    \item before --- запуск совета до выполнения точки соединения.
    \item after returning --- запуск совета после нормального выполнения 
      точки соединения.
    \item after throwing --- запуск совета после выброса исключения в 
      процессе выполнения точки соединения.
    \item after --- запуск совета после любого варианта выполнения точки 
      соединения.
    \item around --- запуск совета вместо выполнения точки соединения 
      (выполнение точки соединения может быть вызвано внутри совета).
  \end{itemize}
После чего следуют параметры и описание среза, в котором могут использоваться
ранее описанные срезы, имеющие собственный идентификатор.
В листинге~\ref{lst:aspectj_example} представлен пример описания аспекта в 
AspectJ:
  \begin{lstlisting}[language=Java, label={lst:aspectj_example}, 
  caption={Пример описания аспектов в AspectJ}]
aspect A  {
  pointcut fooPC(): execution(void Test.foo());
  pointcut printPC(): call(void System.out.println(String));
  
  before(): cflow(fooPC()) && printPC() {
    System.out.println("Hello, world!");
  }
}
  \end{lstlisting}

В данном примере описывается две точки включения:
  \begin{itemize}
    \item fooPC(), которая включает в себя все места выполнения функции foo 
      класса Test, которая возвращает void и не принимает аргументов.
    \item printPC(), которая включает в себя все места вызовов функции 
      System. out. println( String ), которая принимает строку и не 
      возвращает ничего.
  \end{itemize}
Описание совета говорит о том, что он должен быть применен в точках 
printPC, которые находятся внутри потока управления точки fooPC, т.е. во 
всех местах внутри функции void Test.foo(), где вызывается метод void 
System.out.println (String).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{SpringAOP}
\label{sub:spring_aop_overwiev}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
